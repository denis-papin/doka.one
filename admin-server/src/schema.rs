

pub (crate) const DK_SCHEMA : &str =  r#"

CREATE SCHEMA {customer_schema}
       AUTHORIZATION postgres;

SET search_path = {customer_schema}, pg_catalog;

CREATE TABLE document
(
  ID BIGSERIAL NOT NULL ,
  FILE_REF CHARACTER VARYING (50) NOT NULL,
  PART_NO INTEGER NOT NULL,
  DOC_TEXT text NOT NULL,
  TSV tsvector NOT NULL,
  LANG VARCHAR(20) NOT NULL
);
ALTER TABLE DOCUMENT ADD CONSTRAINT DOC_TO_FILE_REF_FK FOREIGN KEY (FILE_REF)
        REFERENCES FILE_REFERENCE (FILE_REF) ON DELETE CASCADE;
ALTER TABLE DOCUMENT ADD CONSTRAINT DOCUMENT_FILE_IDENT_UK  UNIQUE (FILE_REF, PART_NO);
ALTER TABLE DOCUMENT ADD CONSTRAINT DOCUMENT_PK PRIMARY KEY ( ID );

CREATE INDEX DOCUMENT_ID_IDX ON DOCUMENT (ID);
CREATE INDEX DOCUMENT_FILE_IDENT_IDX ON DOCUMENT (FILE_REF, PART_NO);
CREATE INDEX DOCUMENT_FTSV_IDX ON DOCUMENT USING gin (TSV);
CREATE INDEX DOCUMENT_LANGUAGE_IDX ON DOCUMENT (LANGUAGE);

CREATE TABLE PREVIEW
  (
    ID                BIGSERIAL NOT NULL ,
    FILE_REFERENCE_ID BIGINT NOT NULL ,
    FILE_REF          CHARACTER VARYING (50) NOT NULL,
    SORT_ORDER        SMALLINT NOT NULL
  );
ALTER TABLE PREVIEW ADD CONSTRAINT PREVIEW_PK PRIMARY KEY ( ID ) ;
ALTER TABLE PREVIEW ADD CONSTRAINT PREV_F_REF_UK UNIQUE ( FILE_IDENTIFIER ) ;
ALTER TABLE PREVIEW ADD CONSTRAINT PREV_F_REF_AND_SORT_UK UNIQUE ( FILE_IDENTIFIER,  SORT_ORDER ) ;
ALTER TABLE PREVIEW ADD CONSTRAINT PREV_F_IDENT_AND_F_REF_UK UNIQUE ( FILE_IDENTIFIER,  FILE_REFERENCE_ID ) ;
ALTER TABLE PREVIEW ADD CONSTRAINT PREV_TO_FILE_REF_FK FOREIGN KEY (FILE_REFERENCE_ID) REFERENCES FILE_REFERENCE (ID) ON DELETE CASCADE;

CREATE INDEX PREVIEW_FILE_REF_ID_IDX ON PREVIEW
  (
    FILE_REFERENCE_ID
  ) ;


CREATE TABLE ITEM
  (
    ID BIGSERIAL NOT NULL ,
    NAME CHARACTER VARYING(255) NOT NULL,
    CREATED_GMT       TIMESTAMP (0) WITHOUT TIME ZONE NOT NULL ,
    LAST_MODIFIED_GMT TIMESTAMP (0) WITHOUT TIME ZONE NOT NULL
  ) ;

CREATE INDEX ITEM_CREATED_IDX ON ITEM
  ( CREATED_GMT  ) ;
CREATE INDEX ITEM_LAST_MODIFIED_IDX ON ITEM
  ( LAST_MODIFIED_GMT  ) ;
--  This is Accent-Insensitive index, speed up NAME like '%ABC%' queries
CREATE INDEX ITEM_NAME_GIN_IDX ON ITEM USING gin
  (
    public.unaccent_lower(NAME) public.gin_trgm_ops
  ) ;
-- GIN index do not support comparison, so adding a regular B-tree index too to speed-up ORDER BY: also done with "C" ("POSIX") collation
CREATE INDEX ITEM_NAME_BTREE_IDX ON ITEM
  (
    public.unaccent_lower(NAME) COLLATE "C"
  ) ;

ALTER TABLE ITEM ADD CONSTRAINT ITEM_PK PRIMARY KEY ( ID ) ;

CREATE TABLE DOCUMENT
(
  ID BIGSERIAL NOT NULL ,
  FILE_IDENTIFIER CHARACTER VARYING (50) NOT NULL,
  PART_NO INTEGER NOT NULL,
  DOC_TEXT text NOT NULL,
  TSV tsvector NOT NULL,
  LANGUAGE CHAR(3) NOT NULL
);
ALTER TABLE DOCUMENT ADD CONSTRAINT DOC_TO_FILE_REF_FK FOREIGN KEY (FILE_IDENTIFIER)
        REFERENCES FILE_REFERENCE (FILE_IDENTIFIER) ON DELETE CASCADE;
ALTER TABLE DOCUMENT ADD CONSTRAINT DOCUMENT_FILE_IDENT_UK  UNIQUE (FILE_IDENTIFIER, PART_NO);
ALTER TABLE DOCUMENT ADD CONSTRAINT DOCUMENT_PK PRIMARY KEY ( ID );

CREATE INDEX DOCUMENT_ID_IDX ON DOCUMENT (ID);
CREATE INDEX DOCUMENT_FILE_IDENT_IDX ON DOCUMENT (FILE_IDENTIFIER, PART_NO);
CREATE INDEX DOCUMENT_FTSV_IDX ON DOCUMENT USING gin (TSV);
CREATE INDEX DOCUMENT_LANGUAGE_IDX ON DOCUMENT (LANGUAGE);

CREATE OR REPLACE PROCEDURE insert_document(FILE_REF VARCHAR,  PART_NO INTEGER, DOC_TEXT VARCHAR, TSV VARCHAR, LANG VARCHAR)
LANGUAGE SQL
AS $$
   INSERT INTO document( FILE_REF,  PART_NO, DOC_TEXT, TSV, LANG )
        VALUES ( FILE_REF, PART_NO, DOC_TEXT,
				TSV :: TSVECTOR
				,  LANG );
$$;

---
---
---

CREATE TABLE TAG_DEFINITION
  (
    ID BIGSERIAL NOT NULL ,
    NAME              CHARACTER VARYING (25) NOT NULL ,
    TYPE              CHARACTER VARYING (25) NOT NULL ,
    STRING_TAG_LENGTH INTEGER,
    DEFAULT_VALUE     CHARACTER VARYING(255),
    CHECK (STRING_TAG_LENGTH BETWEEN 0 AND 10000000)
  ) ;
ALTER TABLE TAG_DEFINITION ADD CONSTRAINT TAG_PK PRIMARY KEY ( ID );
ALTER TABLE TAG_DEFINITION ADD CONSTRAINT TAG_NAME_UK UNIQUE ( NAME );
ALTER TABLE TAG_DEFINITION ADD CONSTRAINT length_limit CHECK (STRING_TAG_LENGTH BETWEEN 0 AND 10000000);

CREATE TABLE TAG_VALUE
  (
    ID     BIGSERIAL NOT NULL,
    TAG_ID BIGINT NOT NULL,
    ITEM_ID BIGINT NOT NULL,
    VALUE_BOOLEAN BOOLEAN,
    VALUE_STRING CHARACTER VARYING(2000) ,
    VALUE_INTEGER  BIGINT,
    VALUE_DOUBLE   DOUBLE PRECISION,
    VALUE_DATE     DATE ,
    VALUE_DATETIME TIMESTAMP (0) WITHOUT TIME ZONE
  ) ;

CREATE INDEX TAG_VALUE_BOOLEAN_IDX ON TAG_VALUE  ( VALUE_BOOLEAN );
CREATE INDEX TAG_VALUE_INTEGER_IDX ON TAG_VALUE (  VALUE_INTEGER  ) ;
CREATE INDEX TAG_VALUE_DOUBLE_IDX ON TAG_VALUE  (  VALUE_DOUBLE  ) ;
CREATE INDEX TAG_VALUE_DATE_IDX ON TAG_VALUE  (  VALUE_DATE  ) ;
CREATE INDEX TAG_VALUE_DATETIME_IDX ON TAG_VALUE  ( VALUE_DATETIME  ) ;
CREATE INDEX TAG_VALUE_STR_LIKE_GIN_IDX ON TAG_VALUE USING gin
  (
    public.unaccent_lower(VALUE_STRING) public.gin_trgm_ops
  ) ;

CREATE INDEX TAG_VALUE_STR_SORT_BTREE_IDX ON TAG_VALUE
  (
    public.unaccent_lower(VALUE_STRING) COLLATE "C"
  ) ;

ALTER TABLE TAG_VALUE ADD CONSTRAINT TAG_VALUE_PK PRIMARY KEY ( ID ) ;


ALTER TABLE FILE_REFERENCE ADD CONSTRAINT FILE_REFERENCE_ITEM_FK FOREIGN KEY ( ITEM_ID ) REFERENCES ITEM ( ID ) ON DELETE CASCADE;

    "#;